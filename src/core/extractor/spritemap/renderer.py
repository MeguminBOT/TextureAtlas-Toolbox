"""High-level Adobe Spritemap renderer for extracting symbol animations.

Provides ``AdobeSpritemapRenderer``, which loads an Adobe Animate export
(Animation.json + spritemap JSON + atlas PNG) and renders each symbol or
timeline label into cropped RGBA frames.

Two rendering strategies are available:

* **Batch** via :meth:`~AdobeSpritemapRenderer.build_animation_frames` —
  renders every animation into memory at once.  Required when editor
  composites need cross-animation frame references.
* **Streaming** via :meth:`~AdobeSpritemapRenderer.iter_animations` —
  yields one ``(name, lazy_frame_iterator)`` at a time so the caller can
  export and free frames before the next animation is rendered, keeping
  peak memory proportional to the largest single animation.
"""

from __future__ import annotations

import json
import math
from typing import Any, Dict, Generator, Iterator, List, Optional, Tuple

from PIL import Image

from utils.utilities import Utilities
from .sprite_atlas import SpriteAtlas
from .symbols import Symbols
from .metadata import collect_referenced_symbols
from .normalizer import normalize_animation_document
from .transform_matrix import TransformMatrix


class AdobeSpritemapRenderer:
    """Render symbol animations from Adobe Animate spritemap exports.

    Loads the animation metadata, spritemap JSON, and atlas image on
    construction, then exposes methods to list symbols, render frames,
    and populate default FPS settings.

    Attributes:
        animation_path: Filesystem path to Animation.json.
        spritemap_json_path: Filesystem path to the spritemap JSON.
        atlas_image_path: Filesystem path to the atlas bitmap.
        animation_json: Parsed Animation.json dict.
        frame_rate: Frames-per-second from metadata (default 24).
        filter_single_frame: Whether to skip single-frame animations.
        filter_unused_symbols: Whether to hide symbols not used by the root
            animation timeline.
        sprite_atlas: ``SpriteAtlas`` instance for sprite lookup.
        symbols: ``Symbols`` instance for timeline/symbol management.
    """

    def __init__(
        self,
        animation_path: str,
        spritemap_json_path: str,
        atlas_image_path: str,
        canvas_size=None,
        resample=Image.BICUBIC,
        filter_single_frame: bool = True,
        filter_unused_symbols: bool = False,
        root_animation_only: bool = False,
    ):
        """Load animation metadata, spritemap JSON, and the atlas image.

        Args:
            animation_path: Path to Animation.json generated by Adobe Animate.
            spritemap_json_path: Path to the per-spritesheet JSON file.
            atlas_image_path: Path to the atlas bitmap.
            canvas_size: Optional ``(width, height)`` override for the render
                canvas; defaults to atlas dimensions.
            resample: Pillow resample filter for scaling operations.
            filter_single_frame: When ``True``, animations with only one frame
                are omitted from batch renders.
            filter_unused_symbols: When ``True``, symbols not referenced by the
                root animation timeline are excluded from batch operations.
            root_animation_only: When ``True``, only the root animation is
                included in batch operations; symbols and labels are excluded.
        """

        self.animation_path = animation_path
        self.spritemap_json_path = spritemap_json_path
        self.atlas_image_path = atlas_image_path

        with open(animation_path, "r", encoding="utf-8") as animation_file:
            self.animation_json = normalize_animation_document(
                json.load(animation_file)
            )

        with open(spritemap_json_path, "rb") as spritemap_file:
            spritemap_json = json.loads(spritemap_file.read().decode("utf-8-sig"))

        atlas_image = Image.open(atlas_image_path)
        if canvas_size is None:
            canvas_size = _infer_canvas_size(
                self.animation_json,
                spritemap_json,
                atlas_image.size,
            )
        self.frame_rate = self.animation_json.get("MD", {}).get("FRT", 24)
        self.filter_single_frame = filter_single_frame
        self.filter_unused_symbols = filter_unused_symbols
        self.root_animation_only = root_animation_only
        self._referenced_symbols = (
            collect_referenced_symbols(self.animation_json)
            if filter_unused_symbols
            else None
        )
        self.sprite_atlas = SpriteAtlas(
            spritemap_json, atlas_image, canvas_size, resample
        )
        self.symbols = Symbols(self.animation_json, self.sprite_atlas, canvas_size)

    def get_root_animation_name(self) -> Optional[str]:
        """Return the display name of the root animation, if available.

        The root animation is defined by the top-level ``AN`` section of
        the Animation.json document.  Its display name comes from ``AN.SN``
        (the symbol name) with a fallback to ``AN.N`` (the internal name).

        Returns:
            The root animation name, or ``None`` when the document has no
            ``AN`` section.
        """
        an = self.animation_json.get("AN", {})
        return an.get("SN") or an.get("N") or None

    def is_symbol_referenced(self, symbol_name: str) -> bool:
        """Check whether a symbol is used by the root animation timeline.

        Always returns ``True`` when ``filter_unused_symbols`` is disabled.

        Args:
            symbol_name: The symbol name to check.

        Returns:
            True if the symbol is transitively referenced by the root
            animation, or if filtering is disabled.
        """
        if self._referenced_symbols is None:
            return True
        return symbol_name in self._referenced_symbols

    def list_symbol_names(self, include_all: bool = False) -> List[str]:
        """Return symbol names defined in the animation document.

        Args:
            include_all: When ``True``, return every symbol regardless of
                the ``filter_unused_symbols`` setting.

        Returns:
            List of symbol name strings.
        """
        names = [
            symbol.get("SN")
            for symbol in self.animation_json.get("SD", {}).get("S", [])
            if symbol.get("SN")
        ]
        if include_all or self._referenced_symbols is None:
            return names
        return [n for n in names if n in self._referenced_symbols]

    def build_animation_frames(
        self,
    ) -> Dict[str, List[Tuple[str, Image.Image, Tuple[int, int, int, int, int, int]]]]:
        """Render frames for every symbol and timeline label at once.

        All rendered frames are held in memory simultaneously.  Prefer
        :meth:`iter_animations` for large spritesheets unless editor
        composites require cross-animation frame access.

        Symbols and labels that resolve to a single frame are skipped when
        ``filter_single_frame`` is enabled.

        Returns:
            Dict mapping folder/label names to lists of frame tuples. Each
            tuple contains ``(frame_name, image, bounds)`` where bounds is
            ``(x, y, width, height, offset_x, offset_y)``.
        """

        animations: Dict[
            str, List[Tuple[str, Image.Image, Tuple[int, int, int, int, int, int]]]
        ] = {}

        # Render the root animation (full AN timeline) if it exists
        root_name = self.get_root_animation_name()
        if root_name:
            root_frames = self._render_symbol_frames(None)
            if root_frames:
                if not self.filter_single_frame or len(root_frames) > 1:
                    animations.setdefault(root_name, []).extend(root_frames)

        if not self.root_animation_only:
            for symbol_name in self.list_symbol_names():
                frames = self._render_symbol_frames(symbol_name)
                if not frames:
                    continue
                if self.filter_single_frame and len(frames) <= 1:
                    continue
                folder_name = Utilities.strip_trailing_digits(symbol_name)
                animations.setdefault(folder_name, []).extend(frames)

            for label in self.symbols.get_label_ranges(None):
                frames = self._render_symbol_frames(
                    None,
                    start_frame=label["start"],
                    end_frame=label["end"],
                    frame_name_prefix=label["name"],
                )
                if not frames:
                    continue
                if self.filter_single_frame and len(frames) <= 1:
                    continue
                folder_name = label["name"]
                animations.setdefault(folder_name, []).extend(frames)

        return animations

    #: Shape of a single rendered frame: ``(name, PIL Image, bounds_6tuple)``.
    FrameTuple = Tuple[str, Image.Image, Tuple[int, int, int, int, int, int]]

    def iter_animations(
        self,
    ) -> Generator[
        Tuple[str, Iterator["AdobeSpritemapRenderer.FrameTuple"]],
        None,
        None,
    ]:
        """Yield ``(folder_name, frame_iterator)`` one animation at a time.

        Each ``frame_iterator`` is a lazy generator that renders frames
        one at a time via :meth:`_iter_symbol_frames`.  Only one compact
        canvas is alive at any moment, keeping rendering memory at O(1)
        rather than O(N) frames.

        The caller **must fully consume** (or discard) the ``frame_iterator``
        before advancing this outer generator to the next animation.

        Yields:
            Tuples of ``(folder_name, frame_iterator)`` where
            ``frame_iterator`` yields ``(frame_name, image, bounds)``.
        """
        root_name = self.get_root_animation_name()
        if root_name:
            total = self.symbols.length(None)
            if not self.filter_single_frame or total > 1:
                yield root_name, self._iter_symbol_frames(None)

        if not self.root_animation_only:
            for symbol_name in self.list_symbol_names():
                total = self.symbols.length(symbol_name)
                if total == 0:
                    continue
                if self.filter_single_frame and total <= 1:
                    continue
                folder_name = Utilities.strip_trailing_digits(symbol_name)
                yield folder_name, self._iter_symbol_frames(symbol_name)

            for label in self.symbols.get_label_ranges(None):
                total = label["end"] - label["start"]
                if total <= 0:
                    continue
                if self.filter_single_frame and total <= 1:
                    continue
                yield label["name"], self._iter_symbol_frames(
                    None,
                    start_frame=label["start"],
                    end_frame=label["end"],
                    frame_name_prefix=label["name"],
                )

    def _render_symbol_frames(
        self,
        symbol_name: Optional[str],
        start_frame: int = 0,
        end_frame: Optional[int] = None,
        frame_name_prefix: Optional[str] = None,
    ):
        """Render a contiguous range of frames for a symbol or timeline label.

        Uses a three-phase strategy to minimise memory consumption:

        1. **Bounds pass** — walks the symbol tree with transform math only
           (no images allocated) to compute the tightest viewport that
           contains every frame in the range.
        2. **Compact render pass** — renders each frame onto a canvas sized
           to just the viewport instead of the full inferred canvas.
        3. **Pixel crop pass** — computes the pixel-content union bounding
           box across all rendered frames, then crops each frame to that
           box and closes the intermediate compact canvas.

        Used by :meth:`build_animation_frames`.  For low-memory streaming,
        see :meth:`_iter_symbol_frames` which omits Phase 3.

        Args:
            symbol_name: Name of the symbol, or ``None`` for the root timeline.
            start_frame: First frame index to render (inclusive).
            end_frame: Last frame index (exclusive); defaults to total length.
            frame_name_prefix: Prefix for generated frame names.

        Returns:
            List of ``(name, image, bounds)`` tuples, or empty if no valid
            frames exist.
        """

        total_frames = self.symbols.length(symbol_name)
        if total_frames == 0:
            return []

        if end_frame is None or end_frame > total_frames:
            end_frame = total_frames

        if start_frame >= end_frame:
            return []

        union_bounds = self.symbols.compute_union_bounds(
            symbol_name, start_frame, end_frame
        )
        if union_bounds is None:
            return []

        frames_with_index: List[Tuple[int, Image.Image]] = []
        for frame_index in range(start_frame, end_frame):
            frame_image = self.symbols.render_symbol_compact(
                symbol_name, frame_index, union_bounds
            )
            if frame_image is not None:
                frames_with_index.append((frame_index - start_frame, frame_image))

        if not frames_with_index:
            return []

        min_x, min_y, max_x, max_y = float("inf"), float("inf"), 0, 0
        for _, frame in frames_with_index:
            bbox = frame.getbbox()
            if bbox:
                min_x = min(min_x, bbox[0])
                min_y = min(min_y, bbox[1])
                max_x = max(max_x, bbox[2])
                max_y = max(max_y, bbox[3])

        if min_x > max_x:
            return []

        prefix = frame_name_prefix or (symbol_name if symbol_name else "timeline")

        rendered_frames: List[
            Tuple[str, Image.Image, Tuple[int, int, int, int, int, int]]
        ] = []
        for frame_index, frame in frames_with_index:
            cropped_frame = frame.crop((min_x, min_y, max_x, max_y))
            frame.close()
            frame_name = f"{prefix}_{frame_index:04d}"
            rendered_frames.append(
                (
                    frame_name,
                    cropped_frame,
                    (0, 0, cropped_frame.width, cropped_frame.height, 0, 0),
                )
            )

        return rendered_frames

    def _iter_symbol_frames(
        self,
        symbol_name: Optional[str],
        start_frame: int = 0,
        end_frame: Optional[int] = None,
        frame_name_prefix: Optional[str] = None,
    ) -> Generator[
        Tuple[str, Image.Image, Tuple[int, int, int, int, int, int]],
        None,
        None,
    ]:
        """Yield rendered frames one at a time for a symbol or label.

        Like :meth:`_render_symbol_frames` but renders lazily: only one
        compact canvas is alive at any moment.  The Phase 3 pixel-level
        union crop from ``_render_symbol_frames`` is omitted so frames can
        be yielded immediately.  Downstream callers (e.g.
        ``pad_frames_to_canvas`` and the GIF exporter ``crop_option``)
        handle size normalisation.

        Args:
            symbol_name: Name of the symbol, or ``None`` for the root timeline.
            start_frame: First frame index to render (inclusive).
            end_frame: Last frame index (exclusive); defaults to total length.
            frame_name_prefix: Prefix for generated frame names.

        Yields:
            ``(frame_name, pil_image, bounds_tuple)`` for each rendered frame.
        """
        total_frames = self.symbols.length(symbol_name)
        if total_frames == 0:
            return

        if end_frame is None or end_frame > total_frames:
            end_frame = total_frames

        if start_frame >= end_frame:
            return

        viewport = self.symbols.compute_union_bounds(
            symbol_name, start_frame, end_frame
        )
        if viewport is None:
            return

        prefix = frame_name_prefix or (symbol_name if symbol_name else "timeline")

        for frame_index in range(start_frame, end_frame):
            frame_image = self.symbols.render_symbol_compact(
                symbol_name, frame_index, viewport
            )
            if frame_image is None:
                continue
            frame_name = f"{prefix}_{frame_index - start_frame:04d}"
            yield (
                frame_name,
                frame_image,
                (0, 0, frame_image.width, frame_image.height, 0, 0),
            )

    def ensure_animation_defaults(self, settings_manager, spritesheet_name):
        """Populate animation duration defaults in the settings manager if missing.

        Iterates over all symbols and timeline labels and ensures each has an
        entry in ``settings_manager.animation_settings`` with at least a
        ``duration`` key (in milliseconds).

        Args:
            settings_manager: A settings manager exposing ``animation_settings``.
            spritesheet_name: Base name used to construct full setting keys.
        """
        # Convert fps to milliseconds for default duration
        default_duration_ms = (
            max(1, round(1000 / self.frame_rate)) if self.frame_rate > 0 else 42
        )

        # Ensure defaults for the root animation
        root_name = self.get_root_animation_name()
        if root_name:
            full_name = f"{spritesheet_name}/{root_name}"
            sprite_settings = settings_manager.animation_settings.setdefault(
                full_name, {}
            )
            sprite_settings.setdefault("duration", default_duration_ms)

        if not self.root_animation_only:
            for animation_name in self.list_symbol_names():
                folder_name = Utilities.strip_trailing_digits(animation_name)
                full_name = f"{spritesheet_name}/{folder_name}"
                sprite_settings = settings_manager.animation_settings.setdefault(
                    full_name, {}
                )
                sprite_settings.setdefault("duration", default_duration_ms)

            for label in self.symbols.get_label_ranges(None):
                label_name = label["name"]
                full_name = f"{spritesheet_name}/{label_name}"
                sprite_settings = settings_manager.animation_settings.setdefault(
                    full_name, {}
                )
                sprite_settings.setdefault("duration", default_duration_ms)

    def render_animation(self, target):
        """Render frames for a symbol or timeline label.

        Args:
            target: Either a symbol name string, or a dict with ``type`` and
                ``value`` keys (type may be ``"symbol"`` or ``"timeline_label"``).

        Returns:
            List of ``(name, image, bounds)`` tuples for the requested target.
        """

        target_type, target_value = self._normalize_target(target)

        if target_type == "root_animation":
            root_name = self.get_root_animation_name()
            return self._render_symbol_frames(None, frame_name_prefix=root_name)

        if target_type == "timeline_label":
            label_range = self.symbols.get_label_range(None, target_value)
            if not label_range:
                return []
            return self._render_symbol_frames(
                None,
                start_frame=label_range["start"],
                end_frame=label_range["end"],
                frame_name_prefix=target_value,
            )

        return self._render_symbol_frames(target_value)

    def _normalize_target(self, target):
        """Normalize a render target to a ``(type, value)`` pair.

        Args:
            target: A string (treated as symbol name) or dict with ``type``
                and ``value`` keys.

        Returns:
            Tuple of ``(target_type, target_value)``.
        """

        if isinstance(target, dict):
            return target.get("type", "symbol"), target.get("value")
        return "symbol", target

    def close(self) -> None:
        """Release renderer resources.

        Closes the ``Symbols`` and ``SpriteAtlas`` instances, then drops the
        parsed animation JSON so memory can be reclaimed.
        """

        if getattr(self, "symbols", None):
            try:
                self.symbols.close()
            except Exception:
                pass
            finally:
                self.symbols = None

        if getattr(self, "sprite_atlas", None):
            try:
                self.sprite_atlas.close()
            except Exception:
                pass
            finally:
                self.sprite_atlas = None

        self.animation_json = None


def _infer_canvas_size(animation_json, spritemap_json, atlas_size):
    """Compute a canvas size large enough to contain all transformed sprites.

    Scans every symbol timeline and atlas sprite instance, applying their
    transforms to determine the maximum extent any sprite can reach. The
    returned dimensions ensure no sprite is clipped during rendering.

    Args:
        animation_json: Normalized Animation.json dict.
        spritemap_json: Parsed spritemap JSON with sprite regions.
        atlas_size: Default ``(width, height)`` from the atlas image.

    Returns:
        A ``(width, height)`` tuple at least as large as ``atlas_size`` and
        sufficient to hold all transformed sprite bounds.
    """

    sprite_sizes = _collect_sprite_sizes(spritemap_json)
    if not sprite_sizes:
        return atlas_size

    timelines = _collect_timelines(animation_json)
    if not timelines:
        return atlas_size

    bounds_cache: Dict[Optional[str], Optional[Tuple[float, float, float, float]]] = {}
    visiting: set[Optional[str]] = set()

    def symbol_bounds(
        symbol_name: Optional[str],
    ) -> Optional[Tuple[float, float, float, float]]:
        """Return the cumulative bounding box for all frames of a symbol.

        Recursively resolves nested symbol instances and caches results to
        avoid redundant traversals. Cyclic references are detected via the
        ``visiting`` set and return ``None`` to break infinite loops.

        Args:
            symbol_name: Name of the symbol, or ``None`` for the root timeline.

        Returns:
            A ``(min_x, min_y, max_x, max_y)`` tuple, or ``None`` if the
            symbol has no renderable content.
        """

        if symbol_name in bounds_cache:
            return bounds_cache[symbol_name]
        if symbol_name in visiting:
            return None
        visiting.add(symbol_name)

        min_x = float("inf")
        min_y = float("inf")
        max_x = float("-inf")
        max_y = float("-inf")

        for layer in timelines.get(symbol_name, []):
            for frame in layer.get("FR", []):
                for element in frame.get("E", []):
                    bounds = _element_bounds(element, sprite_sizes, symbol_bounds)
                    if not bounds:
                        continue
                    min_x = min(min_x, bounds[0])
                    min_y = min(min_y, bounds[1])
                    max_x = max(max_x, bounds[2])
                    max_y = max(max_y, bounds[3])

        visiting.remove(symbol_name)

        if min_x == float("inf"):
            bounds_cache[symbol_name] = None
        else:
            bounds_cache[symbol_name] = (min_x, min_y, max_x, max_y)
        return bounds_cache[symbol_name]

    for symbol_name in timelines.keys():
        symbol_bounds(symbol_name)

    max_abs_x = 0.0
    max_abs_y = 0.0
    for bounds in bounds_cache.values():
        if not bounds:
            continue
        min_x, min_y, max_x, max_y = bounds
        max_abs_x = max(max_abs_x, abs(min_x), abs(max_x))
        max_abs_y = max(max_abs_y, abs(min_y), abs(max_y))

    if max_abs_x == 0 and max_abs_y == 0:
        return atlas_size

    padding = 32.0
    inferred_width = int(math.ceil(max_abs_x * 2.0 + padding))
    inferred_height = int(math.ceil(max_abs_y * 2.0 + padding))
    return (
        max(atlas_size[0], inferred_width),
        max(atlas_size[1], inferred_height),
    )


def _collect_sprite_sizes(spritemap_json: Dict[str, Any]) -> Dict[str, Tuple[int, int]]:
    """Build a mapping of sprite names to their pixel dimensions.

    Args:
        spritemap_json: Parsed spritemap JSON containing an ``ATLAS.SPRITES``
            list.

    Returns:
        Dict mapping each sprite name to its ``(width, height)`` in pixels.
    """

    sizes: Dict[str, Tuple[int, int]] = {}
    for sprite in spritemap_json.get("ATLAS", {}).get("SPRITES", []):
        data = sprite.get("SPRITE", sprite)
        name = data.get("name")
        if not name:
            continue
        sizes[name] = (int(data.get("w", 0)), int(data.get("h", 0)))
    return sizes


def _collect_timelines(animation_json: Dict[str, Any]):
    """Extract all symbol timelines from a normalized animation document.

    Args:
        animation_json: Normalized Animation.json dict with ``SD`` (symbol
            dictionary) and ``AN`` (root animation) sections.

    Returns:
        Dict mapping symbol names (or ``None`` for the root timeline) to
        their layer lists.
    """

    timelines: Dict[Optional[str], List[Dict[str, Any]]] = {}
    for symbol in animation_json.get("SD", {}).get("S", []):
        name = symbol.get("SN")
        if not name:
            continue
        layers = symbol.get("TL", {}).get("L", [])
        timelines[name] = layers
    timelines[None] = animation_json.get("AN", {}).get("TL", {}).get("L", [])
    return timelines


def _element_bounds(element, sprite_sizes, symbol_bounds_fn):
    """Compute the transformed bounding box for a single frame element.

    Handles both atlas sprite instances (``ASI``) and nested symbol instances
    (``SI``), recursively resolving child symbol bounds when necessary.

    Args:
        element: A frame element dict potentially containing ``ASI`` or ``SI``.
        sprite_sizes: Dict mapping sprite names to ``(width, height)``.
        symbol_bounds_fn: Callable accepting a symbol name and returning its
            cumulative bounds, used for recursive symbol resolution.

    Returns:
        A ``(min_x, min_y, max_x, max_y)`` tuple, or ``None`` if the element
        cannot be resolved.
    """

    if not isinstance(element, dict):
        return None
    if "ASI" in element:
        atlas = element["ASI"]
        sprite_name = atlas.get("N")
        if not sprite_name:
            return None
        sprite_size = sprite_sizes.get(sprite_name)
        if not sprite_size:
            return None
        matrix = TransformMatrix.parse(atlas.get("M3D"))
        return _transform_sprite(sprite_size, matrix)
    if "SI" in element:
        instance = element["SI"]
        child_name = instance.get("SN")
        if not child_name:
            return None
        child_bounds = symbol_bounds_fn(child_name)
        if not child_bounds:
            return None
        matrix = TransformMatrix.parse(instance.get("M3D"))
        return _transform_bounds(child_bounds, matrix)
    return None


def _transform_sprite(sprite_size: Tuple[int, int], matrix: TransformMatrix):
    """Apply a transform to an origin-anchored sprite and return its bounds.

    Args:
        sprite_size: ``(width, height)`` of the sprite in pixels.
        matrix: Affine transform to apply.

    Returns:
        Transformed ``(min_x, min_y, max_x, max_y)`` bounding box.
    """

    width, height = sprite_size
    return _transform_bounds((0.0, 0.0, float(width), float(height)), matrix)


def _transform_bounds(
    bounds: Tuple[float, float, float, float], matrix: TransformMatrix
) -> Tuple[float, float, float, float]:
    """Transform a bounding box and return its axis-aligned enclosure.

    Applies the affine transform to each corner of the input rectangle and
    computes the smallest axis-aligned rectangle containing the results.

    Args:
        bounds: ``(min_x, min_y, max_x, max_y)`` rectangle.
        matrix: Affine transform to apply.

    Returns:
        Transformed ``(min_x, min_y, max_x, max_y)`` bounding box.
    """

    min_x, min_y, max_x, max_y = bounds
    corners = (
        (min_x, min_y),
        (min_x, max_y),
        (max_x, min_y),
        (max_x, max_y),
    )
    a, b, c, d, e, f = matrix.m.reshape(-1)[:6]
    transformed = ((a * x + b * y + c, d * x + e * y + f) for (x, y) in corners)
    xs, ys = zip(*transformed)
    return (min(xs), min(ys), max(xs), max(ys))
